package examples;import java.util.ArrayList;import uk.ac.shef.wit.simmetrics.similaritymetrics.*;import java.util.Collections;import java.util.List;import java.util.NoSuchElementException;import rita.wordnet.RiWordnet;public class WordNetDemo {	public static List<String> FindSubstring(RiWordnet wordnet ,String string){		int length = string.length(); 		String sub = null;		List<String> returnString = new ArrayList<String>();		for( int c = 0 ; c < length ; c++ )	      {	         for( int j = 1 ; j <= length - c ; j++ )	         {	            sub = string.substring(c, c+j);	            if(wordnet.exists(sub) && sub.length() >3 ){	            	//System.out.println(sub);	            	returnString.add(sub);	            }	         }	      }		return returnString;	}		private static int minimum(int a, int b, int c) {		return Math.min(Math.min(a, b), c);	} 	public static float computeLevenshteinDistance(String str1,String str2) {		int[][] distance = new int[str1.length() + 1][str2.length() + 1]; 		for (int i = 0; i <= str1.length(); i++)			distance[i][0] = i;		for (int j = 1; j <= str2.length(); j++)			distance[0][j] = j; 		for (int i = 1; i <= str1.length(); i++)			for (int j = 1; j <= str2.length(); j++)				distance[i][j] = minimum(						distance[i - 1][j] + 1,						distance[i][j - 1] + 1,						distance[i - 1][j - 1]+ ((str1.charAt(i - 1) == str2.charAt(j - 1)) ? 0 : 1)); 		float returnValue = distance[str1.length()][str2.length()]/Math.max(str1.length(),str2.length());    		return(1-returnValue);	}	public static float semanticDistance(String start, String end){		RiWordnet wordnet = new RiWordnet(null);		String pos;			List<String> listStart = FindSubstring(wordnet, start);		List<String> listEnd = FindSubstring(wordnet, end);		List<Float> distance = new ArrayList<Float>();		try {			for (String s : listStart)				for (String e : listEnd) {					pos = wordnet.getBestPos(s);					float dist = 1 - wordnet.getDistance(s, e, pos);					distance.add(dist);					//System.out.println(s + " and " + e + " are related by a distance of: " + (dist));				}			return Collections.max(distance);		} catch (NoSuchElementException e) {			System.out.println("No Semantic Similarity");			return 0;		}	}		public static void useSimMetric(String str1,String str2){        AbstractStringMetric metric = new Levenshtein();//        AbstractStringMetric metric = new CosineSimilarity();//        AbstractStringMetric metric = new EuclideanDistance();//        AbstractStringMetric metric = new MongeElkan();        //this single line performs the similarity test        float result = metric.getSimilarity(str1, str2);        //outputs the results        System.out.println("Using Metric " + metric.getShortDescriptionString() +         		" on strings \"" + str1 + "\" & \"" + str2 + "\" gives a similarity score of " + result);	}	public static void main(String args[]){		String start = "password";		String end = "drowssap";		useSimMetric(start,end);		System.out.println(semanticDistance(start, end));		System.out.println(computeLevenshteinDistance(start,end));	}}